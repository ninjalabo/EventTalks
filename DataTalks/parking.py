# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/02_parking_tools.ipynb.

# %% ../nbs/02_parking_tools.ipynb 1
"""
Fintraffic Parking helpers for “Arena Buddy”.
--------------------------------------------

* Uses v1 REST (2025-04-08 spec)
* No authentication needed for GET
"""

from __future__ import annotations
import math, datetime as dt, httpx, asyncio
from typing import Dict, Tuple, List

# ── Constants ─────────────────────────────────────────────────────────────
_FT_BASE = "https://parking.fintraffic.fi/api/v1"
_HEAD    = {"Digitraffic-User": "datatalks-bot"}           # track usage
_EARTH_R = 6_371_000.0                                     # metres
AREENA   = (60.1778, 24.7858)                              # Urheilupuisto

# single async client reused by all helpers
_client = httpx.AsyncClient(headers=_HEAD, timeout=10)

# ── Geometry helpers ──────────────────────────────────────────────────────
def _haversine(a: Tuple[float, float], b: Tuple[float, float]) -> float:
    """Great-circle distance (m) between two (lat, lon) pairs."""
    lat1, lon1, lat2, lon2 = map(math.radians, (*a, *b))
    dlat, dlon = lat2 - lat1, lon2 - lon1
    h = (math.sin(dlat / 2) ** 2 +
         math.cos(lat1) * math.cos(lat2) * math.sin(dlon / 2) ** 2)
    return _EARTH_R * 2 * math.asin(math.sqrt(h))

def _latlon(fac: dict) -> Tuple[float, float]:
    """Return (lat, lon) from any facility/hub row (v0 or v1 schema)."""
    if "lat" in fac and "lon" in fac:          # legacy fields
        return fac["lat"], fac["lon"]

    loc = fac.get("location") or {}
    coords = loc.get("coordinates")
    if coords is None:
        raise KeyError("No coordinates in location")

    gtype = loc.get("type", "").upper()

    if gtype == "POINT":                       # [lon, lat]
        lon, lat = coords[:2]
    elif gtype == "POLYGON":                   # [[[lon, lat], …]]
        lon, lat = coords[0][0][:2]            # first vertex is good enough
    else:                                      # unexpected but try MP-like
        lon, lat = coords[0][:2]               # works for MultiPoint
    return lat, lon

# ── Public helpers ────────────────────────────────────────────────────────
async def nearest_parking_ids(
    lat: float,
    lon: float,
    *,
    radius_m: int = 800
) -> Dict[str, int]:
    """
    Nearest facilityId for each capacityType (keys often 'CAR', 'BICYCLE').

    Returns e.g. ``{'CAR': 285, 'BICYCLE': 1457}``.  Keys are absent if no
    facility of that capacityType exists within *radius_m*.
    """
    q = {"lat": lat, "lon": lon, "within.maxDistance": radius_m}
    rows = (await _client.get(f"{_FT_BASE}/facilities", params=q)).json()["results"]

    here = (lat, lon)
    best: Dict[str, Tuple[float, int]] = {}
    for fac in rows:
        plat, plon = _latlon(fac)
        for ctype, cap in fac.get("builtCapacity", {}).items():
            if cap <= 0:
                continue
            dist = _haversine(here, (plat, plon))
            if ctype not in best or dist < best[ctype][0]:
                best[ctype] = (dist, fac["id"])

    return {k: v[1] for k, v in best.items()}

async def parking_status(
    facility_id: int,
    *,
    capacity_type: str = "CAR",
    usage: str = "PARK_AND_RIDE",
) -> dict:
    """
    Live vacancy for *facility_id* and a given capacity/usage pair.

    Returns ::

        {
          "capacity": 320,
          "spacesAvailable": 147,
          "timestamp_utc": "2025-05-20T15:56:03Z",
          "openNow": True
        }
    """
    rows = (await _client.get(f"{_FT_BASE}/facilities/{facility_id}/utilization")).json()
    row  = next(r for r in rows
                if r["capacityType"] == capacity_type and r["usage"] == usage)

    ts_utc = (dt.datetime.fromisoformat(row["timestamp"])
              .astimezone(dt.timezone.utc).isoformat(timespec="seconds"))

    return {
        "capacity":        row["capacity"],
        "spacesAvailable": row["spacesAvailable"],
        "timestamp_utc":   ts_utc,
        "openNow":         row["openNow"],
    }

async def facility_prediction(
    facility_id: int,
    *,
    hours: int = 24
) -> List[dict]:
    """
    1–24 h forecast list (may be empty if Fintraffic has no ML model yet). ::

        [{'timestamp': '2025-05-20T17:00:00Z', 'spacesAvailable': 110}, …]
    """
    rows = (await _client.get(f"{_FT_BASE}/facilities/{facility_id}/prediction",
                              params={"after": f"{hours}:00"})).json()
    return rows


# %% auto 0
__all__ = ['AREENA', 'nearest_parking_ids', 'parking_status', 'facility_prediction']
